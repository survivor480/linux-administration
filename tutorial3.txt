cp /etc/passwd ./users.txt

This copies the contents of the first mentioned file to the second mentioned file

cp -v /etc/group ./users.txt

The v stands for verbose here. It displays the output as '/etc/group' -> './users.txt'

Now if we want it to prompt before overwriting, what we can do is

cp -i /etc/group ./users.txt

This will display a prompt before overwriting the contents to the file

cp learning_linux.txt logs users.txt first/

This will copy the three files to the destination directory

sudo cp -r /etc/ ~/Desktop

This recursively iterates through the directly and copies all the folders and files to the destination
This command wont work in case we remove the recursive option

mv c.txt dir1/a.txt dir1/b.txt dir1/dir2/

Moves all the mentioned files to the destination

mv dir1/dir2/*.txt dir1/

This moves all the files with the extension of .txt to the mentioned directory

For generating a prompt for overwriting a file, we can use -i option

mv -i dir1/dir2/a.txt dir1/

To rename a file then, this is the procedure to be followed,

mv dir1/a.txt dir1/abc.txt

This renames the file from a.txt to abc.txt

A directory can also be renamed in the same way

To rename the file and then move it, there is a special way

mv dir10/c.txt dir10/dir2/cc.txt

This moves the files into the destination with the name cc.txt

There is no concept of trash or Recycle bin for files which are deleted from the cli.

rm -i dir10/dir2/b.txt

This generates a prompt which upon given consent, deletes the files

To delete a directory, use

rm -r dir10

Now if we create a file like sudo touch a.txt, this file will belong to root but the user
student is allowed to delete it, (student in this example) since the file will be present in the
home directory of the user

To force removal and not receive a prompt for each file, we can use the -f option.

rm -rf Music/ Pictures/

echo *.txt

This prints the files that will match the given pattern.

To safely delete a file, we can use the shred command to write the file with random contents before completely
removing it

shred -vu -n 100 passwd


##########################
## Working with files and directory (touch, mkdir, cp, mv, rm, shred)
##########################
 
# creating a new file or updating the timestamps if the file already exists
touch filename
 
# creating a new directory
mkdir dir1
 
# creating a directory and its parents as well
mkdir -p mydir1/mydir2/mydir3
 
######################
### The cp command ###
######################
# copying file1 to file2 in the current directory
cp file1 file2
 
# copying file1 to dir1 as another name (file2)
cp file1 dir1/file2
 
# copying a file prompting the user if it overwrites the destination
cp -i file1 file2
 
# preserving the file permissions, group and ownership when copying
cp -p file1 file2
 
# being verbose
cp -v file1 file2
 
# recursively copying dir1 to dir2 in the current directory
cp -r dir1 dir2/
 
# copy more source files and directories to a destination directory
cp -r file1 file2 dir1 dir2 destination_directory/
 
 
######################
### The mv command ###
######################
# renaming file1 to file2
mv file1 file2
 
# moving file1 to dir1 
mv file1 dir1/
 
# moving a file prompting the user if it overwrites the destination file
mv -i file1 dir1/
 
# preventing a existing file from being overwritten
mv -n file1 dir1/
 
# moving only if the source file is newer than the destination file or when the destination file is missing
mv -u file1 dir1/
 
# moving file1 to dir1 as file2
mv file1 dir1/file2
 
# moving more source files and directories to a destination directory
mv file1 file2 dir1/ dir2/ destination_directory/
 
######################
### The rm command ###
######################
# removing a file
rm file1
 
# being verbose when removing a file
rm -v file1
 
# removing a directory
rm -r dir1/
 
# removing a directory without prompting
rm -rf dir1/
 
# removing a file and a directory prompting the user for confirmation
rm -ri fil1 dir1/
 
# secure removal of a file (verbose with 100 rounds of overwriting)
shred -vu -n 100 file1


Q) mkdir ubuntu/centos
mkdir: cannot create directory 'ubuntu/centos': No such file or directory

Why did the user get that error?

Answer: Because neither of the directories exist. Add the -p option.

Every linux command or program that we run has three data streams connected to it:

stdin(0):- Standard Input
stdout(1):- Standard Output
stderr(2): Standard Error

Now we can connect two commands with each other. If we wish to see all the files in the given directory,
according to their size, that list may be huge and we may not be able to see it.
So to see only the head of the output,

ls -lSh /etc/ | head

This gives us only the starting lines of the command.

Now we can pipe any number of commands at once.

ls -lSh /etc/ | head -n 20 | tail -n 1

This command displays only the 20th line of the command.

Now if we want to see how many authentication errors took place, there is no such command to come across but we can make one such work for us.

First we display all the authentication logs, which is cat /var/log/auth.log
In the cat command, we can add the option -n to see the file along with the line numbers

Now, we try to count the number of authentication failures, we can use the grep command to fetch that.
Grep command actually finds the string and displays it.

cat -n /var/log/auth.log | grep -a "authentication failure"

Now, there is another command wc which returns how many lines are displayed

cat -n /var/log/auth.log | grep -a "authentication failure" | wc -l

This displays the output as a number(6 in this case). wc is short for word count.

The wc command provides different statistics about a file, it shows the number of lines, number of words and number of characters that are present in the
file.

wc /etc/passwd
This gives the result as 48 83 2825 /etc/passwd

-l will display the line count in wc
-w will display the word count in wc
-c will display the character count in wc

Command redirection is done by > sign.

ls -l > ls.txt will write the output of the ls -l command to the ls.txt file

In case of command redirection, it will create the file if it already exists then it will overwrite the file

To append to the file, we can use the >> sign

ls -l > output.txt

ifconfig >> output.txt

>> creates the file if it doesnot exist, or appends to the file in case it exists.

Everything is file in linux. To demonstrate it, we open the file responsible for the terminal.

For this we use the tty command,
The output for this is /dev/pts/1

Now we can use the second terminal to display output in the first terminal

ifconfig > /dev/pts/0

This displays the output of the terminal in the previous terminal.

Now to display the error interface in the file we can use

tail -n 3 /etc/shadow 2> error.txt

This displays the error in the txt file. Note that 2 > is not allowed, 2> is the original syntax.

It is possible to redirect the error of a command in some file and the normal output in another file.

For example: tail -n 2 /etc/passwd /etc/shadow

This generates an error in case of the shadow file, since we dont have the required privileges.

So to redirect the output, all we have to do is,

tail -n 3 /etc/passwd /etc/shadow > output.txt 2> error.txt

TO redirect the standard output as well as the standard error in one file, we can execute the following command

tail -n 2 /etc/passwd /etc/shadow > output.txt 2>&1

This writes the standard output as well as the standard error inside the file

To get the mac_id of the ethernet connection, what we can do is execute the following command

ifconfig | grep ether | cut -d" " -f10 > mac.txt

This shows the mac address of the ethernet port of that device

cut -d":" -f1 /etc/passwd
This shows all the users in the file passwd.
The f1 here is the label of the delimiter in each line.

Now what if we want to create a file and write all the output into it, as well as print the output to the screen.

To get the running kernel version of the distribution, we can write

uname -r


##########################
## Piping and Command Redirection
##########################
 
## Piping Examples:
 
ls -lSh /etc/ | head            # see the first 10 files by size
ps -ef | grep sshd              # checking if sshd is running
ps aux --sort=-%mem | head -n 3  # showing the first 3 process by memory consumption
 
## Command Redirection
 
# output redirection
ps aux > running_processes.txt
who -H > loggedin_users.txt
 
# appending to a file
id >> loggedin_users.txt
 
# output and error redirection
tail -n 10 /var/log/*.log > output.txt 2> errors.txt
 
# redirecting both the output and errors to the same file
tail -n 2 /etc/passwd /etc/shadow > output_errors.txt 2>&1
 
cat -n /var/log/auth.log | grep -ai "authentication failure" | wc -l
cat -n /var/log/auth.log | grep -ai "authentication failure" > auth.txt     # => piping and redirection


We need to install the locate command by using

sudo apt-get install mlocate

We update the database used by locate by the command sudo updatedb

ls /var/lib/mlocate
locate -S

The basic usage of the command is to locate the name of the file or directory we want to find

locate passwords

By default the locate command will replace it like *eahorse* in the command locate eahorse

Adding -b option suggests it to find the string only in the basename rather than the entire string

Now to find out the exact file with that exact name, we can use a backslash

locate -b '\shadow'

This will search all the files with the name shadow

Now if we create a file and then try to locate just after that, it wont be able to locate that file since,
the database which is used while searching the files is not updated yet.

Hence sudo updatedb, then try locating the file

Now the problem is that if we remove the file, even after that locate suggests the file to be there.

To avoid this there is an option provided, which is -e which checks for the existence of the file, if it really exists.

linux is a case sensitive operating system and locate command is no different. But using the -i option,
locate -i Rainshadow
we can find a few files

Now, we can also locate a file using regular expressions,
locate -b -r '^shadow\.[0-9]'
This command is to find the files which start with shadow, then followed by a dot, and then any number

Using the which command, it displays the first executable it finds regarding the command
which rm
has an output of /usr/bin/rm

If we want to view all matching executables, we can use the -a command

##########################
## Finding Files (find, locate)
##########################
 
## LOCATE ##
# updating the locate db
sudo updatedb
 
# displaying statistics
locate -S
 
# finding file by name
locate filename # => filename is expanded to *filename*
locate -i filename # => the filename is case insensitive
locate -b '\filename' # => finding by exact name
 
# finding using the basename
locate -b filename
 
# finding using regular expressions
locate -r 'regex'
 
# checking that the file exists
locate -e filename
 
# showing command path
which command
which -a command
 
 
## FIND ##
find PATH OPTIONS
 
# Example: find ~ -type f -size +1M # => finding all files in ~ bigger than 1 MB
 
## Options:
# -type f, d, l, s, p
# -name filename
# -iname filename # => case-insensitive
# -size n, +n, -n
# -perm permissions
# -links n, +n, -n
# -atime n, -mtime n, ctime n
# -user owner
# -group group_owner


To find a directory or a file by name or date or any pattern, we can use the find command

find . -name todo.txt

if we use -iname instead of -name, the search will be case insensitive.

find . -name todo will show us nothing in case we dont have the exact file inside the directory we are at.

But if we want all the files without caring of the extension, we can use find . -name todo*

If we pass the delete option, it will delete the file with no possibility of recovering it.

find . -name todo.txt -delete

Another command we can pass is the -ls command with the find command such that it will run the ls command on every
file it finds

sudo find /etc/ -name passwd -ls

If we want to search for directories in the given folder,

find \etc\ -type d

We can also specify the maximum depth to which the find command can go,

find /etc/ -type d -maxdepth 2

We have another option -perm which will search by those exact permissions

find /etc/ -type d -maxdepth 2 -perm 755

find /var -type f -size 100k -ls

It will search for files of size 100k rounded up to the next unit.

If we want files between the size of 5M and 10M, we can use

sudo find /var -type f -size +5M -size -10M 

If we want to see files modified within the past 24 hours,

find /var -type f -mtime 0 -ls

Here mtime 1 means files modified between 1 and 2 days ago. mtime 0 means files modified between 0 and 1 day ago.

If you want to search by minute instead of days use -mmin, -amin etc.

To search for files that belong to a particular user,
find /var/ -type f gdm -ls

TO execute a command along with find, we can use
sudo find /etc -type f -mtime 0 -exec cat {} \;

This will execute the cat command to all the files it finds in the find command. The command ends when it finds
the \ sign

We can also copy the files we get into a seperate folder by using the cp command along with the find command
sudo find /etc -type f -mtime 0 -exec cp {} /root/backup \;

To find the specific pattern in a particular file we can use the grep command in the following way.

grep user /etc/ssh/ssh_config

Adding -i finds it without caring about the case.
Adding -n gives the line numbers where it found the lines

To find the exact word in the file we can use the -w option

Using the -v option will invert the match. It will list the lines that donot contain the word.

To find the text recursively in the dictionary, we can use the -R option

To suppress the errors about the non readable or the non accessible files, use -s option

-c option displays the count of the occurences in the output.

grep -c error /var/log/syslog

dmesg command displays the kernel ring buffer. Most of the contents are produced by the device drivers.

If we give the command
dmesg | grep -A 3 -B 4 error
This displays 4 lines before the match and 3 lines after it.

If we want exactly 3 lines before and 3 lines after,
dmesg | grep -C 3 error
This prints 3 lines before the match and 3 lines after

sudo netstat -tupan shows the available ports which have some processes running

If we want to see what is running on port 53, we can use
sudo netstat -tupan | grep 53

To exclude the empty lines in grep, we can use
ls -RF /etc/ | grep -v / | grep -v "^$"

To sort the output, we can use the sort command
sudo ls -RF /etc/ | grep -v / | grep -v "^$" | sort -r
sort -r will sort it in the reverse manner

##########################
## Searching for text patterns (grep)
##########################
 
grep [OPTIONS] pattern file
 
Options:
-n          # => print line number
-i          # => case insensitive
-v          # inverse the match
-w          # search for whole words
-a          # search in binary files
-R          # search in directory recursively
-c          # display only the no. of matches
-C n        # display a context (n lines before and after the match)
 
 
# printing ASCII chars from a binary file
strings binary_file





